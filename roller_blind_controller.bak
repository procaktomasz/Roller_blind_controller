substitutions:
  cover_name: "Sterownik roleta 1" # nazwa w Home Assistant
  id_cover: "sterownik_cover" # id encji w ESPHome
  esphome_name: "sterownik-roleta-1" # nazwa urządzenia w ESPHome
  step_total: 500  # domyślna liczba kroków silnika krokowego dla pełnego zamknięcia rolety
  accel: inf # prędkosć przyspieszenia silnika krokowego, wartość inf oznacza brak ograniczeń
  decel: inf # prędkośc hamowania silnika krokowego, wartość inf oznacza brak ograniczeń
  max_speed: 600.0  # prędkość silnika krokowego

globals:
  - id: pending_publish
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_pos
    type: int
    restore_value: no
    initial_value: '0'
  - id: total_steps
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_position_steps
    type: int
    restore_value: yes
    initial_value: '0'

esphome:
  name: "${esphome_name}"
  friendly_name: "${cover_name}"
  on_boot:
    priority: 600
    then:
      - lambda: |-
          int steps = id(total_steps);
          if (steps <= 0) {
            steps = ${step_total};
            id(total_steps) = steps;
          }
          int stored = id(last_position_steps);
          if (stored < 0) stored = 0;
          if (stored > steps) stored = steps;
          id(last_position_steps) = stored;
          id(last_pos) = stored;
          id(pending_publish) = false;
          id(my_stepper).report_position(stored);
          id(my_stepper).set_target(stored);
          float pos = 1.0f;
          if (steps > 0) pos = 1.0f - ((float)stored / (float)steps);
          if (pos < 0.0f) pos = 0.0f;
          if (pos > 1.0f) pos = 1.0f;
          sterownik_cover->position = pos;
          id(sterownik_cover).publish_state();

esp8266:
  board: d1_mini
  restore_from_flash: true

wifi:
  networks:
    # - ssid: !secret wifi_ssidc
    #   password: !secret wifi_password
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  fast_connect: true

api:
  on_client_connected:
    - delay: 2000ms
    - lambda: |-
          int steps = id(total_steps);
          if (steps <= 0) {
            steps = ${step_total};
            id(total_steps) = steps;
          }
          int stored = id(last_position_steps);
          if (stored < 0) stored = 0;
          if (stored > steps) stored = steps;
          id(last_position_steps) = stored;
          id(last_pos) = stored;
          id(pending_publish) = false;
          id(my_stepper).report_position(stored);
          id(my_stepper).set_target(stored);
          float pos = 1.0f;
          if (steps > 0) pos = 1.0f - ((float)stored / (float)steps);
          if (pos < 0.0f) pos = 0.0f;
          if (pos > 1.0f) pos = 1.0f;
          sterownik_cover->position = pos;
          id(sterownik_cover).publish_state();

ota:
  platform: esphome
  password: !secret ota_password

logger:
  level: DEBUG
  esp8266_store_log_strings_in_flash: true

web_server:
  port: 80
  auth:
    username: !secret web_server_username
    password: !secret web_server_password
  log: true

captive_portal:

stepper:
  - platform: uln2003
    id: my_stepper
    pin_a: D1
    pin_b: D2
    pin_c: D3
    pin_d: D5
    max_speed: ${max_speed}
    sleep_when_done: true
    acceleration: ${accel}
    deceleration: ${decel}
    step_mode: FULL_STEP

cover:
  - platform: template
    name: "${cover_name}"
    id: ${id_cover}
    optimistic: false
    has_position: true
    position_action:
      - lambda: |-
          float steps = (float)id(total_steps);
          if (steps <= 0.0f) steps = 1.0f;
          float target = (1.0f - pos) * steps;
          if (target < 0.0f) target = 0.0f;
          if (target > steps) target = steps;
          int target_steps = (int)target;
          id(pending_publish) = true;
          id(last_pos) = (int)id(my_stepper).current_position;
          id(last_position_steps) = target_steps;
          id(my_stepper).set_target(target_steps);
    open_action:
      - lambda: |-
          id(pending_publish) = true;
          id(last_pos) = (int)id(my_stepper).current_position;
          id(last_position_steps) = 0;
          id(my_stepper).set_target(0);
    close_action:
      - lambda: |-
          int cur = (int)id(my_stepper).current_position;
          int target_steps;
          if (id(calibration_mode).state) {
            target_steps = cur + 200000;  // zapewnij długi zjazd w trybie kalibracji
          } else {
            target_steps = id(total_steps);
            if (target_steps <= 0) target_steps = 1;
          }
          id(pending_publish) = true;
          id(last_pos) = cur;
          if (id(calibration_mode).state) {
            id(last_position_steps) = cur;
          } else {
            id(last_position_steps) = target_steps;
          }
          id(my_stepper).set_target(target_steps);
    stop_action:
      - lambda: |-
          int cur = (int)id(my_stepper).current_position;
          id(pending_publish) = true;
          id(last_pos) = cur;
          id(my_stepper).set_target(cur);
          id(last_position_steps) = cur;

interval:
  - interval: 1s
    then:
      - lambda: |-
          if (id(pending_publish)) {
            int cur = (int)id(my_stepper).current_position;
            if (cur == id(last_pos)) {
              float steps = (float)id(total_steps);
              float pos = 0.0f;
              if (steps > 0.0f) pos = 1.0f - ((float)cur / steps);
              if (pos < 0.0f) pos = 0.0f;
              if (pos > 1.0f) pos = 1.0f;
              sterownik_cover->position = pos;
              id(sterownik_cover).publish_state();
              id(last_position_steps) = cur;
              id(pending_publish) = false;
            } else {
              id(last_pos) = cur;
            }
          }

switch:
  - platform: template
    name: "Kalibracja"
    id: calibration_mode
    optimistic: true

button:
  - platform: template
    name: "Kalibracja - ustaw jako otwarta"
    id: btn_calib_open
    on_press:
      - lambda: |-
          if (!id(calibration_mode).state) {
            ESP_LOGW("calibration", "Tryb kalibracji jest wylaczony");
            return;
          }
          id(my_stepper).report_position(0);
          id(last_pos) = 0;
          sterownik_cover->position = 1.0f;
          id(pending_publish) = false;
          id(sterownik_cover).publish_state();
          id(last_position_steps) = 0;
  - platform: template
    name: "Kalibracja - ustaw jako zamknieta"
    id: btn_calib_closed
    on_press:
      - lambda: |-
          if (!id(calibration_mode).state) {
            ESP_LOGW("calibration", "Tryb kalibracji jest wylaczony");
            return;
          }
          int cur = (int)id(my_stepper).current_position;
          if (cur <= 0) cur = 1;
          id(total_steps) = cur;
          id(last_pos) = cur;
          sterownik_cover->position = 0.0f;
          id(pending_publish) = false;
          id(sterownik_cover).publish_state();
          id(last_position_steps) = cur;
  - platform: template
    name: "Kalibracja - reset kalibracji"
    id: btn_calib_reset
    on_press:
      - lambda: |-
          if (!id(calibration_mode).state) {
            ESP_LOGW("calibration", "Tryb kalibracji jest wylaczony");
            return;
          }
          const int defaults = ${step_total};
          id(total_steps) = defaults;
          id(my_stepper).report_position(0);
          id(last_pos) = 0;
          sterownik_cover->position = 1.0f;
          id(pending_publish) = false;
          id(sterownik_cover).publish_state();
          id(last_position_steps) = 0;
